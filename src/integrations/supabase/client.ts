
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';
import { InvoicePayment } from '@/types';

const SUPABASE_URL = "https://heozxmzglhrbrzpsvbrh.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imhlb3p4bXpnbGhyYnJ6cHN2YnJoIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDU4NzIyNTksImV4cCI6MjA2MTQ0ODI1OX0.WDib-BNHRslc7c1wTRdzufT23mCpM-TBhA_CpyxMln4";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

/**
 * Gets all payments for a specific invoice
 */
export const getInvoicePayments = async (invoiceId: string): Promise<InvoicePayment[]> => {
  const { data, error } = await supabase
    .from('invoice_payments')
    .select('*')
    .eq('invoiceid', invoiceId)
    .order('payment_date', { ascending: false });

  if (error) {
    console.error('Error fetching invoice payments:', error);
    throw error;
  }

  // Map the database format to our domain model
  return data.map(payment => ({
    id: payment.id,
    invoiceId: payment.invoiceid,
    amount: payment.amount,
    paymentDate: payment.payment_date,
    paymentMethod: payment.payment_method || 'bank_transfer',
    reference: payment.payment_reference || '',
    notes: payment.notes || '',
    createdAt: payment.created_at || new Date().toISOString()
  }));
};

/**
 * Add a payment to an invoice
 */
export const addInvoicePayment = async (invoiceId: string, paymentData: {
  amount: number;
  paymentDate: string;
  paymentMethod: string;
  reference?: string;
  notes?: string;
}): Promise<InvoicePayment> => {
  // First insert the payment
  const { data, error } = await supabase
    .from('invoice_payments')
    .insert({
      invoiceid: invoiceId,
      amount: paymentData.amount,
      payment_date: paymentData.paymentDate,
      payment_method: paymentData.paymentMethod,
      payment_reference: paymentData.reference,
      notes: paymentData.notes
    })
    .select()
    .single();

  if (error) {
    console.error('Error adding invoice payment:', error);
    throw error;
  }

  // Then update the invoice payment status and amounts
  const { data: invoiceData, error: invoiceError } = await supabase
    .from('final_invoices')
    .select('total, amount_paid')
    .eq('id', invoiceId)
    .single();

  if (invoiceError) {
    console.error('Error fetching invoice for payment update:', invoiceError);
    throw invoiceError;
  }

  // Calculate new paid amount and debt
  const newAmountPaid = (invoiceData.amount_paid || 0) + paymentData.amount;
  const newDebt = invoiceData.total - newAmountPaid;
  
  // Determine status based on payment
  let newStatus;
  if (newAmountPaid >= invoiceData.total) {
    newStatus = 'paid';
  } else if (newAmountPaid > 0) {
    newStatus = 'partially_paid';
  } else {
    newStatus = 'unpaid';
  }

  // Update invoice with new amounts and status
  const { error: updateError } = await supabase
    .from('final_invoices')
    .update({
      amount_paid: newAmountPaid,
      client_debt: newDebt,
      status: newStatus
    })
    .eq('id', invoiceId);

  if (updateError) {
    console.error('Error updating invoice after payment:', updateError);
    throw updateError;
  }

  // Return the payment data in our domain model format
  return {
    id: data.id,
    invoiceId: data.invoiceid,
    amount: data.amount,
    paymentDate: data.payment_date,
    paymentMethod: data.payment_method,
    reference: data.payment_reference || '',
    notes: data.notes || '',
    createdAt: data.created_at
  };
};

/**
 * Delete an invoice payment
 */
export const deleteInvoicePayment = async (paymentId: string, invoiceId: string): Promise<void> => {
  // First get the payment amount to subtract from invoice
  const { data: paymentData, error: paymentError } = await supabase
    .from('invoice_payments')
    .select('amount')
    .eq('id', paymentId)
    .single();

  if (paymentError) {
    console.error('Error fetching payment to delete:', paymentError);
    throw paymentError;
  }

  // Delete the payment
  const { error: deleteError } = await supabase
    .from('invoice_payments')
    .delete()
    .eq('id', paymentId);

  if (deleteError) {
    console.error('Error deleting payment:', deleteError);
    throw deleteError;
  }

  // Update the invoice payment status and amounts
  const { data: invoiceData, error: invoiceError } = await supabase
    .from('final_invoices')
    .select('total, amount_paid')
    .eq('id', invoiceId)
    .single();

  if (invoiceError) {
    console.error('Error fetching invoice for payment update:', invoiceError);
    throw invoiceError;
  }

  // Calculate new paid amount and debt
  const newAmountPaid = Math.max(0, (invoiceData.amount_paid || 0) - paymentData.amount);
  const newDebt = invoiceData.total - newAmountPaid;
  
  // Determine status based on payment
  let newStatus;
  if (newAmountPaid >= invoiceData.total) {
    newStatus = 'paid';
  } else if (newAmountPaid > 0) {
    newStatus = 'partially_paid';
  } else {
    newStatus = 'unpaid';
  }

  // Update invoice with new amounts and status
  const { error: updateError } = await supabase
    .from('final_invoices')
    .update({
      amount_paid: newAmountPaid,
      client_debt: newDebt,
      status: newStatus
    })
    .eq('id', invoiceId);

  if (updateError) {
    console.error('Error updating invoice after payment deletion:', updateError);
    throw updateError;
  }
};

// Map invoice payment fields from database to domain model and vice versa
export const mapDbInvoicePaymentToDomain = (dbPayment: any): InvoicePayment => {
  return {
    id: dbPayment.id,
    invoiceId: dbPayment.invoiceid,
    amount: dbPayment.amount,
    paymentDate: dbPayment.payment_date,
    paymentMethod: dbPayment.payment_method || 'bank_transfer',
    reference: dbPayment.payment_reference || '',
    notes: dbPayment.notes || '',
    createdAt: dbPayment.created_at || new Date().toISOString()
  };
};

export const mapDomainInvoicePaymentToDb = (payment: InvoicePayment): any => {
  return {
    id: payment.id,
    invoiceid: payment.invoiceId,
    amount: payment.amount,
    payment_date: payment.paymentDate,
    payment_method: payment.paymentMethod,
    payment_reference: payment.reference,
    notes: payment.notes,
    created_at: payment.createdAt
  };
};
